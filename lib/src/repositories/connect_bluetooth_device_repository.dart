part of '../../viam_flutter_bluetooth_provisioning_widget.dart';

class ConnectBluetoothDeviceRepository {
  BluetoothDevice? get device => _device;
  Stream<BluetoothConnectionState?> get bluetoothConnectionStateStream => _stateController.stream;
  BluetoothConnectionState? get bluetoothConnectionState => _bluetoothConnectionState;
  set bluetoothConnectionState(BluetoothConnectionState? state) {
    if (_bluetoothConnectionState != state) {
      _bluetoothConnectionState = state;
      _stateController.add(state);
    }
  }

  final StreamController<BluetoothConnectionState?> _stateController = StreamController<BluetoothConnectionState>.broadcast();
  BluetoothConnectionState? _bluetoothConnectionState;
  StreamSubscription<BluetoothConnectionState>? _connectionStateSubscription;
  BluetoothDevice? _device;

  void dispose() {
    _connectionStateSubscription?.cancel();
    _connectionStateSubscription = null;
    _stateController.close();
  }

  Future<void> connect(BluetoothDevice device) async {
    if (device.isConnected) {
      _successfullyConnected(device);
      return;
    }
    await device.connect();
    _successfullyConnected(device);
  }

  Future<void> reconnect() async {
    if (_device?.isConnected == false && _device != null) {
      await connect(_device!);
      debugPrint('reconnected to device');
    }
  }

  Future<void> writeConfig({
    required Viam viam,
    required Robot robot,
    required RobotPart mainRobotPart,
    required String? ssid,
    required String? password,
    required String psk,
    required String? fragmentId,
    required bool fragmentOverride,
  }) async {
    if (_device == null || _device?.isConnected == false) {
      throw Exception('No connected device');
    }

    final status = await _device!.readStatus();
    // don't overwrite existing machine, hotspot provisioning also does this check
    if (!status.isConfigured) {
      await _device!.writeRobotPartConfig(
        partId: mainRobotPart.id,
        secret: mainRobotPart.secret,
        psk: psk,
      );
    }
    if (ssid != null) {
      await _device!.writeNetworkConfig(ssid: ssid, pw: password, psk: psk);
    }
    if (fragmentOverride) {
      final fragmentIdToWrite = fragmentId ?? await _device!.readFragmentId();
      if (fragmentIdToWrite.isNotEmpty) {
        await _fragmentOverride(viam, fragmentIdToWrite, mainRobotPart, robot);
      }
    }
    await _device!.exitProvisioning(psk: psk);
  }

  Future<List<WifiNetwork>> readNetworkList() async {
    if (_device == null || _device?.isConnected == false) {
      throw Exception('No connected device');
    }

    final wifiNetworks = await _device!.readNetworkList();
    return wifiNetworks.sorted((a, b) => b.signalStrength.compareTo(a.signalStrength));
  }

  void _successfullyConnected(BluetoothDevice device) {
    _connectionStateSubscription = device.connectionState.listen((state) {
      bluetoothConnectionState = state;
    });
    _device = device;
  }

  /// Version check to compare against a specified minimum version
  /// If we can't read the version, it's also in a version below what we support
  Future<bool> isAgentVersionBelowMinimum(String minimumVersion) async {
    if (_device == null || _device?.isConnected == false) {
      throw Exception('No connected device');
    }

    try {
      final agentVersion = await _device!.readAgentVersion();
      return isVersionLower(currentVersionStr: agentVersion, minimumVersionStr: minimumVersion);
    } catch (e) {
      debugPrint('Error reading agent version: $e');
      return true;
    }
  }

  bool isVersionLower({required String currentVersionStr, required String minimumVersionStr}) {
    // extract version numbers using regex (e.g., "0.20.4-release" -> "0.20.4")
    final versionRegex = RegExp(r'^(\d+\.\d+\.\d+)');
    String cleanCurrentVersion = versionRegex.firstMatch(currentVersionStr)?.group(1) ?? currentVersionStr;
    String cleanMinimumVersion = versionRegex.firstMatch(minimumVersionStr)?.group(1) ?? minimumVersionStr;
    List<int> currentIntList = cleanCurrentVersion.split('.').map(int.tryParse).whereType<int>().toList();
    List<int> minimumIntList = cleanMinimumVersion.split('.').map(int.tryParse).whereType<int>().toList();

    if (currentIntList.isEmpty) {
      return false; // no numbers, allow 'custom' pre-release versions to be higher than minimum
    }
    // not using the factory constructor because it can't parse 1.20 properly, so we'll convert that to 1.20.0
    final currentVersion = Version(
      currentIntList.elementAtOrNull(0) ?? 0,
      currentIntList.elementAtOrNull(1) ?? 0,
      currentIntList.elementAtOrNull(2) ?? 0,
    );
    final minimumVersion = Version(
      minimumIntList.elementAtOrNull(0) ?? 0,
      minimumIntList.elementAtOrNull(1) ?? 0,
      minimumIntList.elementAtOrNull(2) ?? 0,
    );
    return currentVersion < minimumVersion;
  }

  Future<void> _fragmentOverride(Viam viam, String fragmentId, RobotPart robotPart, Robot robot) async {
    Map<String, dynamic> config = {
      "fragments": [
        {
          "id": fragmentId,
        }
      ]
    };
    await viam.appClient.updateRobotPart(robotPart.id, robot.name, config);
  }
}
